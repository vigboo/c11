flush ruleset

# Actual interface mapping (as per docker-compose order, inspected in fw):
#   eth0 = users_net   (192.168.1.0/24)
#   eth1 = dmz_net     (192.168.2.0/24)
#   eth2 = servers_net (192.168.0.0/24)
#   eth3 = uplink_net  (172.19.0.0/16)

table inet fw {
  set internal_nets {
    type ipv4_addr;
    flags interval;
    elements = { 192.168.1.0/24, 192.168.2.0/24, 192.168.0.0/24 }
  }
  chain input {
    type filter hook input priority 0;
    ct state established,related accept
    meta l4proto { icmp, icmpv6 } counter accept
    iifname "lo" accept
    tcp dport 22 accept
    ip saddr { 192.168.1.0/24, 192.168.2.0/24, 192.168.0.0/24 } accept
    counter accept
  }

  chain forward {
    type filter hook forward priority 0;
    ct state established,related accept
    meta l4proto { icmp, icmpv6 } counter accept
    ip saddr 192.168.1.0/24 ip daddr 172.17.0.1 accept

    # Allow external/users to reach WAF in DMZ (now listening on 80)
    ip daddr 192.168.2.20 tcp dport 80 accept

    # Allow external MTAs to reach mail server on 25 (servers_net)
    ip daddr 192.168.0.20 tcp dport 25 accept

    # Allow users_net to reach backend directly (intra-lab access)
    ip saddr 192.168.1.0/24 ip daddr 192.168.2.10 tcp dport 80 accept

    # Block any other direct access to backend on 80 not coming from allowed nets
    ip daddr 192.168.2.10 tcp dport 80 drop

    # internal <-> internal: permit
    ip saddr @internal_nets ip daddr @internal_nets accept

    # internal -> external (egress): permit
    ip saddr @internal_nets ip daddr != @internal_nets accept

    # drop unsolicited external -> internal
    ip saddr != @internal_nets ip daddr @internal_nets drop
  }

  chain output {
    type filter hook output priority 0;
    ct state established,related accept
    meta l4proto { icmp, icmpv6 } counter accept
    counter accept
  }
}

## NAT for host-published ports and uplink egress
## Interface mapping:
##   eth0 = users_net   (192.168.1.0/24)
##   eth1 = dmz_net     (192.168.2.0/24)
##   eth2 = servers_net (192.168.0.0/24)
##   eth3 = uplink_net  (172.19.0.0/16)

table ip nat {
  set internal_nets {
    type ipv4_addr;
    flags interval;
    elements = { 192.168.1.0/24, 192.168.2.0/24, 192.168.0.0/24 }
  }  
  chain PREROUTING {
    type nat hook prerouting priority -100;
    # Forward host-exposed ports to internal services
    #ip saddr != @internal_nets tcp dport 80 dnat to 192.168.2.10:80 # Internal -> NGINX
    ip saddr @internal_nets tcp dport 80 dnat to 192.168.2.20:80 # External -> Bunkerweb
    ip saddr != @internal_nets tcp dport 25 dnat to 192.168.0.20:25   # External -> MTA
  }

  chain POSTROUTING {
    type nat hook postrouting priority 100;
    # Ensure return path back via firewall for DNATed flows
    ip daddr 192.168.2.20 tcp dport 80 snat to 192.168.2.254
    ip daddr 192.168.0.20 tcp dport 25 snat to 192.168.0.254
    # Generic egress NAT to uplink
    oifname "eth3" masquerade
  }
}
